"""
# 문재
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

# 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.
"""
N = int(input())
cache = [[0] * 10 for _ in range(101)]


def f(n, d):
    num1 = 0
    num2 = 0
    if cache[n][d]:
        return cache[n][d]
    if n <= 0 or (n == 1 and d == 0):
        return 0
    if n == 1:
        return 1
    if d > 0:
        num1 = f(n-1, d-1)
        cache[n-1][d-1] = num1
    if d < 9:
        num2 = f(n-1, d+1)
        cache[n-1][d+1]
    return num1 + num2


c = 0
for i in range(10):
    c += f(N, i)
print(c % 1_000_000_000)
exit()
# while True:
# N = int(input())
stair_map = {
    '1': [],
    '2': [],
    '3': [],
    '4': [],
    '5': [],
    '6': [],
    '7': [],
    '8': [],
    '9': [],
}


def stair(n, d):
    n += str(d)
    if len(n) == N:
        stair_map[n[0]].append(n)
        return
    if d < 9:
        stair(n, d+1)
    if d > 0:
        stair(n, d-1)


for i in range(1, 10):
    stair('', i)
count = 0
for v in stair_map.values():
    count += len(v)
    print(v)
print(count)
"""
계단수 
다음수가 up/down 중 하나 => -1 / +1  
자릿수 n,  u/d = 2^(n-1)
2^(n-1) * 9 - [2^(n-1) -1]
1 2^1 * 9 - (2^1 - 1) = 17 
2 2^2 * 9 - (2^2 - 1) = 9
3 2^0 * 9 - (2^0 - 1) = 9
4 2^0 * 9 - (2^0 - 1) = 9
5 2^0 * 9 - (2^0 - 1) = 9
6 2^0 * 9 - (2^0 - 1) = 9
7 2^0 * 9 - (2^0 - 1) = 9

1 - 9 []
1 
2 
3 
4 
5 
6 
7 
8 
9

2 - 17  ↑ ↓ - 2 [-1, 1]
10 12 
21 23
32 34
43 45
54 56
65 67
76 78
87 89
98

3 - ↑↑ ↑↓ ↓↓ ↓↑ - 4 [-2, 0, 0 2]
101 123 121      3  
210 212 232 234  4
321 323 343 345  4
...
765 767 787 789  4
876 878 898      3
987 989          2

4 - ↑↑↑ ↑↑↓ ↑↓↓ ↓↓↓ ↓↓↑ ↓↑↑ ↓↑↓ ↑↓↑ - 8 [-3, -1, -1, -1, 1, 1, 1, 3]
1234 1231 1210 x x 1012 1010 1212 6
                                  7
                                  8
                                  ...
                                  8
x                                 7
x x 8987 8765 8767 8789 8787 8989 6                                  
x x x 9876 9878 x 9898 x          3                         
                                  
5 - ↑↑↑↑ ↑↑↑↓ ↑↑↓↓ ↑↓↓↓ ↑↓↓↑ ↑↓↑↑ ↑↓↑↓ ... - 16

        
"""



# 풀이
"""
f(n) = 길이가 n인 계단수 총 개수 
fn(n) = f(n-1) ... ?
 
마지막 숫자 d, 다음 계단수는 d+1 or d-1

계단수 f(n, d)는 f(n+1, d+1), f(n+1, d-1)에 영향을 끼친다.

n = 5
456543210 -> 1, d가 0이면 1만 올 수 있다. 
789 -> 8, d가 9이면 8만 올 수 있다. 
45656 -> 7 / 5, 이외(1~8)는 d±1이 올 수 있다

점화식 정리
f(n, d) := 길이가 n이고 마지막 숫자가 d인 계단수 개수 
d는 0~9
f(N, 0) + f(N, 1) + ... + f(N, 9)를 구하면 됨
f(n,d) = f(n-1, d-1) + f(n-1, d+1)

초기값: 
f(1, 0) = 0
f(1, 1) = 1
f(1, 2) = 1
f(1, 3) = 1
f(1, 4) = 1
f(1, 5) = 1
f(1, 6) = 1
f(1, 7) = 1
f(1, 8) = 1
f(1, 9) = 1
"""

MOD = 1_000_000_000

# cahce[n][d]: 길이가 n, 마지막 숫자각 d인 계단수 개수
cache = [[0] * 10 for _ in range(101)]
for j in range(1, 10):
    cache[1][j] = 1


for i in range(2, 101):
    for j in range(10):
        c1 = cache[i-1][j-1] if j > 0 else 0
        c2 = cache[i-1][j+1] if j < 9 else 0
        cache[i][j] = c1 + c2


ans = 0
# N = int(input())
for j in range(10):
    ans += cache[N][j]
    ans %= MOD

print(ans)